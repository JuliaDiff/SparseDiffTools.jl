<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SparseDiffTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/SparseDiffTools/stable/sparsedifftools/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SparseDiffTools.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SparseDiffTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/master/docs/src/sparsedifftools.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.ApproximateJacobianSparsity" href="#SparseDiffTools.ApproximateJacobianSparsity"><code>SparseDiffTools.ApproximateJacobianSparsity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximateJacobianSparsity(; ntrials = 5, rng = Random.default_rng(),
    epsilon = nothing, alg = GreedyD1Color())</code></pre><p>Use <code>ntrials</code> random vectors to compute the sparsity pattern of the Jacobian. This is an approximate method and the sparsity pattern may not be exact.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `ntrials`: The number of random vectors to use for computing the sparsity pattern
- `rng`: The random number generator used for generating the random vectors
- `alg`: The algorithm used for computing the matrix colors
- `epsilon`: For Finite Differencing based Jacobian Approximations, any number smaller
  than `epsilon` is considered to be zero. If `nothing` is specified, then this value
  is calculated as `100 * eps(eltype(x))`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L115-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.JacPrototypeSparsityDetection" href="#SparseDiffTools.JacPrototypeSparsityDetection"><code>SparseDiffTools.JacPrototypeSparsityDetection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JacPrototypeSparsityDetection(; jac_prototype, alg = GreedyD1Color())</code></pre><p>Use a pre-specified <code>jac_prototype</code> to compute the matrix colors of the Jacobian.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `jac_prototype`: The prototype Jacobian used for computing the matrix colors
- `alg`: The algorithm used for computing the matrix colors</code></pre><p>See Also: <a href="@ref">SymbolicsSparsityDetection</a>, <a href="@ref">PrecomputedJacobianColorvec</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.PrecomputedJacobianColorvec" href="#SparseDiffTools.PrecomputedJacobianColorvec"><code>SparseDiffTools.PrecomputedJacobianColorvec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecomputedJacobianColorvec(jac_prototype, row_colorvec, col_colorvec)</code></pre><p>Use a pre-specified <code>colorvec</code> which can be directly used for sparse differentiation. Based on whether a reverse mode or forward mode or finite differences is used, the corresponding <code>row_colorvec</code> or <code>col_colorvec</code> is used. Atmost one of them can be set to <code>nothing</code>.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- `jac_prototype`: The prototype Jacobian used for computing structural nonzeros
- `row_colorvec`: The row colorvec of the Jacobian
- `col_colorvec`: The column colorvec of the Jacobian</code></pre><p>See Also: <a href="@ref">SymbolicsSparsityDetection</a>, <a href="@ref">JacPrototypeSparsityDetection</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.PrecomputedJacobianColorvec-Tuple{}" href="#SparseDiffTools.PrecomputedJacobianColorvec-Tuple{}"><code>SparseDiffTools.PrecomputedJacobianColorvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PrecomputedJacobianColorvec(; jac_prototype, partition_by_rows::Bool = false,
    colorvec = missing, row_colorvec = missing, col_colorvec = missing)</code></pre><p>Use a pre-specified <code>colorvec</code> which can be directly used for sparse differentiation. Based on whether a reverse mode or forward mode or finite differences is used, the corresponding <code>row_colorvec</code> or <code>col_colorvec</code> is used. Atmost one of them can be set to <code>nothing</code>.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `jac_prototype`: The prototype Jacobian used for computing structural nonzeros
- `partition_by_rows`: Whether to partition the Jacobian by rows or columns (row
  partitioning is used for reverse mode AD)
- `colorvec`: The colorvec of the Jacobian. If `partition_by_rows` is `true` then this
  is the row colorvec, otherwise it is the column colorvec
- `row_colorvec`: The row colorvec of the Jacobian
- `col_colorvec`: The column colorvec of the Jacobian</code></pre><p>See Also: <a href="@ref">SymbolicsSparsityDetection</a>, <a href="@ref">JacPrototypeSparsityDetection</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L68-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.SymbolicsSparsityDetection" href="#SparseDiffTools.SymbolicsSparsityDetection"><code>SparseDiffTools.SymbolicsSparsityDetection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymbolicsSparsityDetection(; alg = GreedyD1Color())</code></pre><p>Use Symbolics to compute the sparsity pattern of the Jacobian. This requires <code>Symbolics.jl</code> to be explicitly loaded.</p><p><strong>Keyword Arguments</strong></p><pre><code class="nohighlight hljs">- `alg`: The algorithm used for computing the matrix colors</code></pre><p>See Also: <a href="@ref">JacPrototypeSparsityDetection</a>, <a href="@ref">PrecomputedJacobianColorvec</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ArrayInterface.matrix_colors" href="#ArrayInterface.matrix_colors"><code>ArrayInterface.matrix_colors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix_colors(A, alg::ColoringAlgorithm = GreedyD1Color();
    partition_by_rows::Bool = false)</code></pre><p>Return the colorvec vector for the matrix A using the chosen coloring algorithm. If a known analytical solution exists, that is used instead. The coloring defaults to a greedy distance-1 coloring.</p><p>Note that if A isa SparseMatrixCSC, the sparsity pattern is defined by structural nonzeroes, ie includes explicitly stored zeros.</p><p>If <code>ArrayInterface.fast_matrix_colors(A)</code> is true, then uses <code>ArrayInterface.matrix_colors(A)</code> to compute the matrix colors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/high_level.jl#L9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.JacVec" href="#SparseDiffTools.JacVec"><code>SparseDiffTools.JacVec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">JacVec(f, u, [p, t]; fu = nothing, autodiff = AutoForwardDiff(), tag = DeivVecTag(),
    kwargs...)</code></pre><p>Returns SciMLOperators.FunctionOperator which computes jacobian-vector product <code>df/du * v</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For non-square jacobians with inplace <code>f</code>, <code>fu</code> must be specified, else <code>JacVec</code> assumes a square jacobian.</p></div></div><pre><code class="language-julia hljs">L = JacVec(f, u)

L * v         # = df/du * v
mul!(w, L, v) # = df/du * v

L(v, p, t)    # = df/dw * v
L(x, v, p, t) # = df/dw * v</code></pre><p><strong>Allowed Function Signatures for <code>f</code></strong></p><p>For Out of Place Functions:</p><pre><code class="language-julia hljs">f(u, p, t)  # t !== nothing
f(u, p)     # p !== nothing
f(u)        # Otherwise</code></pre><p>For In Place Functions:</p><pre><code class="language-julia hljs">f(du, u, p, t)  # t !== nothing
f(du, u, p)     # p !== nothing
f(du, u)        # Otherwise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/differentiation/jaches_products.jl#L223-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.VecJac" href="#SparseDiffTools.VecJac"><code>SparseDiffTools.VecJac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VecJac(f, u, [p, t]; fu = nothing, autodiff = AutoFiniteDiff())</code></pre><p>Returns SciMLOperators.FunctionOperator which computes vector-jacobian product <code>(df/du)ᵀ * v</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For non-square jacobians with inplace <code>f</code>, <code>fu</code> must be specified, else <code>VecJac</code> assumes a square jacobian.</p></div></div><pre><code class="language-julia hljs">L = VecJac(f, u)

L * v         # = (df/du)ᵀ * v
mul!(w, L, v) # = (df/du)ᵀ * v

L(v, p, t; VJP_input = w)    # = (df/du)ᵀ * v
L(x, v, p, t; VJP_input = w) # = (df/du)ᵀ * v</code></pre><p><strong>Allowed Function Signatures for <code>f</code></strong></p><p>For Out of Place Functions:</p><pre><code class="language-julia hljs">f(u, p, t)  # t !== nothing
f(u, p)     # p !== nothing
f(u)        # Otherwise</code></pre><p>For In Place Functions:</p><pre><code class="language-julia hljs">f(du, u, p, t)  # t !== nothing
f(du, u, p)     # p !== nothing
f(du, u)        # Otherwise</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/differentiation/vecjac_products.jl#L53-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools._cols_by_rows-Tuple{Any, Any}" href="#SparseDiffTools._cols_by_rows-Tuple{Any, Any}"><code>SparseDiffTools._cols_by_rows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_cols_by_rows(rows_index,cols_index)</code></pre><p>Returns a vector of rows where each row contains a vector of its column indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/matrix2graph.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools._rows_by_cols-Tuple{Any, Any}" href="#SparseDiffTools._rows_by_cols-Tuple{Any, Any}"><code>SparseDiffTools._rows_by_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rows_by_cols(rows_index,cols_index)</code></pre><p>Returns a vector of columns where each column contains a vector of its row indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/matrix2graph.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, AcyclicColoring}" href="#SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, AcyclicColoring}"><code>SparseDiffTools.color_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_graph(g::Graphs.AbstractGraphs, ::AcyclicColoring)</code></pre><p>Returns a coloring vector following the acyclic coloring rules (1) the coloring corresponds to a distance-1 coloring, and (2) vertices in every cycle of the graph are assigned at least three distinct colors. This variant of coloring is called acyclic since every subgraph induced by vertices assigned any two colors is a collection of trees—and hence is acyclic.</p><p>Reference: Gebremedhin AH, Manne F, Pothen A. <strong>New Acyclic and Star Coloring Algorithms with Application to Computing Hessians</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, BacktrackingColor}" href="#SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, BacktrackingColor}"><code>SparseDiffTools.color_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_graph(g::Graphs.AbstractGraph, ::BacktrackingColor)</code></pre><p>Return a tight, distance-1 coloring of graph g using the minimum number of colors possible (i.e. the chromatic number of graph, <code>χ(g)</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, GreedyStar1Color}" href="#SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, GreedyStar1Color}"><code>SparseDiffTools.color_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_graph(g::Graphs.AbstractGraph, ::GreedyStar1Color)</code></pre><p>Find a coloring of a given input graph such that no two vertices connected by an edge have the same color using greedy approach. The number of colors used may be equal or greater than the chromatic number <code>χ(G)</code> of the graph.</p><p>A star coloring is a special type of distance - 1  coloring, For a coloring to be called a star coloring, it must satisfy two conditions:</p><ol><li>every pair of adjacent vertices receives distinct  colors</li></ol><p>(a distance-1 coloring)</p><ol><li>For any vertex v, any color that leads to a two-colored path</li></ol><p>involving v and three other vertices  is  impermissible  for  v. In other words, every path on four vertices uses at least three colors.</p><p>Reference: Gebremedhin AH, Manne F, Pothen A. <strong>What color is your Jacobian? Graph coloring for computing derivatives.</strong> SIAM review. 2005;47(4):629-705.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/greedy_star1_coloring.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, GreedyStar2Color}" href="#SparseDiffTools.color_graph-Tuple{Graphs.AbstractGraph, GreedyStar2Color}"><code>SparseDiffTools.color_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_graph(g::Graphs.AbstractGraph, ::GreedyStar2Color)</code></pre><p>Find a coloring of a given input graph such that no two vertices connected by an edge have the same color using greedy approach. The number of colors used may be equal or greater than the chromatic number <code>χ(G)</code> of the graph.</p><p>A star coloring is a special type of distance - 1  coloring, For a coloring to be called a star coloring, it must satisfy two conditions:</p><ol><li>every pair of adjacent vertices receives distinct  colors</li></ol><p>(a distance-1 coloring)</p><ol><li>For any vertex v, any color that leads to a two-colored path</li></ol><p>involving v and three other vertices  is  impermissible  for  v. In other words, every path on four vertices uses at least three colors.</p><p>Reference: Gebremedhin AH, Manne F, Pothen A. <strong>What color is your Jacobian? Graph coloring for computing derivatives.</strong> SIAM review. 2005;47(4):629-705.</p><p>TODO: add text explaining the difference between star1 and star2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/greedy_star2_coloring.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.color_graph-Tuple{VertexSafeGraphs.VSafeGraph, ContractionColor}" href="#SparseDiffTools.color_graph-Tuple{VertexSafeGraphs.VSafeGraph, ContractionColor}"><code>SparseDiffTools.color_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_graph(G::VSafeGraph,::ContractionColor)</code></pre><p>Find a coloring of the graph g such that no two vertices connected by an edge have the same color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.color_graph-Tuple{VertexSafeGraphs.VSafeGraph, GreedyD1Color}" href="#SparseDiffTools.color_graph-Tuple{VertexSafeGraphs.VSafeGraph, GreedyD1Color}"><code>SparseDiffTools.color_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">color_graph(g::VSafeGraph, alg::GreedyD1Color)</code></pre><p>Find a coloring of a given input graph such that no two vertices connected by an edge have the same color using greedy approach. The number of colors used may be equal or greater than the chromatic number <code>χ(G)</code> of the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/greedy_d1_coloring.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.contract!-Tuple{VertexSafeGraphs.VSafeGraph, Int64, Int64}" href="#SparseDiffTools.contract!-Tuple{VertexSafeGraphs.VSafeGraph, Int64, Int64}"><code>SparseDiffTools.contract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract!(g, y, x)</code></pre><p>Contract the vertex y to x, both of which belong to graph G, that is delete vertex y and join x with the neighbors of y if they are not already connected with an edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.find-Tuple{Integer, Integer, Graphs.AbstractGraph, DataStructures.DisjointSets{&lt;:Integer}}" href="#SparseDiffTools.find-Tuple{Integer, Integer, Graphs.AbstractGraph, DataStructures.DisjointSets{&lt;:Integer}}"><code>SparseDiffTools.find</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find(w::Integer, x::Integer, g::Graphs.AbstractGraph,
    two_colored_forest::DisjointSets{&lt;:Integer})</code></pre><p>Returns the root of the disjoint set to which the edge connecting vertices w and x in the graph g belongs to</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.find_edge_index-Tuple{Integer, Integer, Graphs.AbstractGraph}" href="#SparseDiffTools.find_edge_index-Tuple{Integer, Integer, Graphs.AbstractGraph}"><code>SparseDiffTools.find_edge_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_edge(g::Graphs.AbstractGraph, v::Integer, w::Integer)</code></pre><p>Returns an integer equivalent to the index of the edge connecting the vertices v and w in the graph g</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.free_colors-Tuple{Integer, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, Vector{Integer}, Graphs.AbstractGraph, Integer}" href="#SparseDiffTools.free_colors-Tuple{Integer, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, Vector{Integer}, Graphs.AbstractGraph, Integer}"><code>SparseDiffTools.free_colors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free_colors(x::Integer,
            A::AbstractVector{&lt;:Integer},
            colors::AbstractVector{&lt;:Integer},
            F::Array{Integer,1},
            g::Graphs.AbstractGraph,
            opt::Integer)</code></pre><p>Returns set of free colors of x which are less than optimal chromatic number (opt)</p><p>Arguments:</p><p>x: Vertex who&#39;s set of free colors is to be calculated A: List of vertices of graph g sorted in non-increasing order of degree colors: colors[i] stores the number of distinct colors used in the         coloring of vertices A[0], A[1]... A[i-1] F: F[i] stores the color of vertex i g: Graph to be colored opt: Current optimal number of colors to be used in the coloring of graph g</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L126-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.grow_star!-Tuple{DataStructures.DisjointSets{&lt;:Integer}, AbstractVector{&lt;:Tuple{Integer, Integer}}, Integer, Integer, Graphs.AbstractGraph, AbstractVector{&lt;:Integer}}" href="#SparseDiffTools.grow_star!-Tuple{DataStructures.DisjointSets{&lt;:Integer}, AbstractVector{&lt;:Tuple{Integer, Integer}}, Integer, Integer, Graphs.AbstractGraph, AbstractVector{&lt;:Integer}}"><code>SparseDiffTools.grow_star!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grow_star!(two_colored_forest::DisjointSets{&lt;:Integer},
    first_neighbor::AbstractVector{&lt;:Tuple{Integer, Integer}}, v::Integer, w::Integer,
    g::Graphs.AbstractGraph, color::AbstractVector{&lt;:Integer})</code></pre><p>Grow a 2-colored star after assigning a new color to the previously uncolored vertex v, by comparing it with the adjacent vertex w. Disjoint set is used to store stars in sets, which are identified through key edges present in g.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L89-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.init_jacobian" href="#SparseDiffTools.init_jacobian"><code>SparseDiffTools.init_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_jacobian(cache::AbstractMaybeSparseJacobianCache)</code></pre><p>Initialize the Jacobian based on the cache. Uses sparse jacobians if possible.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function doesn&#39;t alias the provided jacobian prototype. It always initializes a fresh jacobian that can be mutated without any side effects.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L256-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.init_jacobian-Tuple{SparseDiffTools.AbstractMaybeSparseJacobianCache}" href="#SparseDiffTools.init_jacobian-Tuple{SparseDiffTools.AbstractMaybeSparseJacobianCache}"><code>SparseDiffTools.init_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_jacobian(cache::AbstractMaybeSparseJacobianCache;
    preserve_immutable::Val = Val(false))</code></pre><p>Initialize the Jacobian based on the cache. Uses sparse jacobians if possible.</p><p>If <code>preserve_immutable</code> is <code>true</code>, then the Jacobian returned might be immutable, this is relevant if the inputs are immutable like <code>StaticArrays</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L310-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.insert_new_tree!-Tuple{DataStructures.DisjointSets{&lt;:Integer}, Integer, Integer, Graphs.AbstractGraph}" href="#SparseDiffTools.insert_new_tree!-Tuple{DataStructures.DisjointSets{&lt;:Integer}, Integer, Integer, Graphs.AbstractGraph}"><code>SparseDiffTools.insert_new_tree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert_new_tree!(two_colored_forest::DisjointSets{&lt;:Integer}, v::Integer,
    w::Integer, g::Graphs.AbstractGraph</code></pre><p>creates a new singleton set in the disjoint set &#39;two<em>colored</em>forest&#39; consisting of the edge connecting v and w in the graph g</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.least_index-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, Integer}" href="#SparseDiffTools.least_index-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, Integer}"><code>SparseDiffTools.least_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">least_index(F::AbstractVector{&lt;:Integer}, A::AbstractVector{&lt;:Integer}, opt::Integer)</code></pre><p>Returns least index i such that color of vertex A[i] is equal to <code>opt</code> (optimal chromatic number)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.length_common_neighbor-Tuple{VertexSafeGraphs.VSafeGraph, Int64, Int64}" href="#SparseDiffTools.length_common_neighbor-Tuple{VertexSafeGraphs.VSafeGraph, Int64, Int64}"><code>SparseDiffTools.length_common_neighbor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length_common_neighbor(g, z, x)</code></pre><p>Find the number of vertices that share an edge with both the vertices z and x belonging to the graph g.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.matrix2graph" href="#SparseDiffTools.matrix2graph"><code>SparseDiffTools.matrix2graph</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">matrix2graph(sparse_matrix, [partition_by_rows::Bool=true])</code></pre><p>A utility function to generate a graph from input sparse matrix, columns are represented with vertices and 2 vertices are connected with an edge only if the two columns are mutually orthogonal.</p><p>Note that the sparsity pattern is defined by structural nonzeroes, ie includes explicitly stored zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/matrix2graph.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.max_degree_vertex-Tuple{VertexSafeGraphs.VSafeGraph, Vector{Int64}}" href="#SparseDiffTools.max_degree_vertex-Tuple{VertexSafeGraphs.VSafeGraph, Vector{Int64}}"><code>SparseDiffTools.max_degree_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_degree_vertex(G, nn)</code></pre><p>Find the vertex in the group nn of vertices belonging to the graph G which has the highest degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.max_degree_vertex-Tuple{VertexSafeGraphs.VSafeGraph}" href="#SparseDiffTools.max_degree_vertex-Tuple{VertexSafeGraphs.VSafeGraph}"><code>SparseDiffTools.max_degree_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_degree_vertex(G)</code></pre><p>Find the vertex in graph with highest degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.merge_trees!-Tuple{DataStructures.DisjointSets{&lt;:Integer}, Integer, Integer, Integer, Graphs.AbstractGraph}" href="#SparseDiffTools.merge_trees!-Tuple{DataStructures.DisjointSets{&lt;:Integer}, Integer, Integer, Integer, Graphs.AbstractGraph}"><code>SparseDiffTools.merge_trees!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge_trees!(two_colored_forest::DisjointSets{&lt;:Integer}, v::Integer, w::Integer,
    x::Integer, g::Graphs.AbstractGraph)</code></pre><p>Subroutine to merge trees present in the disjoint set which have a common edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.min_index-Tuple{AbstractVector{&lt;:Integer}, Integer}" href="#SparseDiffTools.min_index-Tuple{AbstractVector{&lt;:Integer}, Integer}"><code>SparseDiffTools.min_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min_index(forbidden_colors::AbstractVector{&lt;:Integer}, v::Integer)</code></pre><p>Returns min{i &gt; 0 such that forbidden_colors[i] != v}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.non_neighbors-Tuple{VertexSafeGraphs.VSafeGraph, Integer}" href="#SparseDiffTools.non_neighbors-Tuple{VertexSafeGraphs.VSafeGraph, Integer}"><code>SparseDiffTools.non_neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">non_neighbors(G, x)</code></pre><p>Find the set of vertices belonging to the graph G which do not share an edge with the vertex x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.prevent_cycle!-Tuple{AbstractVector{&lt;:Tuple{Integer, Integer}}, AbstractVector{&lt;:Integer}, Integer, Integer, Integer, Graphs.AbstractGraph, DataStructures.DisjointSets{&lt;:Integer}, AbstractVector{&lt;:Integer}}" href="#SparseDiffTools.prevent_cycle!-Tuple{AbstractVector{&lt;:Tuple{Integer, Integer}}, AbstractVector{&lt;:Integer}, Integer, Integer, Integer, Graphs.AbstractGraph, DataStructures.DisjointSets{&lt;:Integer}, AbstractVector{&lt;:Integer}}"><code>SparseDiffTools.prevent_cycle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevent_cycle!(first_visit_to_tree::AbstractVector{&lt;:Tuple{Integer, Integer}},
    forbidden_colors::AbstractVector{&lt;:Integer}, v::Integer, w::Integer, x::Integer,
    g::Graphs.AbstractGraph, two_colored_forest::DisjointSets{&lt;:Integer},
    color::AbstractVector{&lt;:Integer})</code></pre><p>Subroutine to avoid generation of 2-colored cycle due to coloring of vertex v, which is adjacent to vertices w and x in graph g. Disjoint set is used to store the induced 2-colored subgraphs/trees where the id of set is an integer representing an edge of graph &#39;g&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/acyclic_coloring.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.remove_higher_colors-Tuple{AbstractVector{&lt;:Integer}, Integer}" href="#SparseDiffTools.remove_higher_colors-Tuple{AbstractVector{&lt;:Integer}, Integer}"><code>SparseDiffTools.remove_higher_colors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_higher_colors(U::AbstractVector{&lt;:Integer}, opt::Integer)</code></pre><p>Remove all the colors which are greater than or equal to the <code>opt</code> (optimal chromatic number) from the set of colors U</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.sort_by_degree-Tuple{Graphs.AbstractGraph}" href="#SparseDiffTools.sort_by_degree-Tuple{Graphs.AbstractGraph}"><code>SparseDiffTools.sort_by_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_by_degree(g::Graphs.AbstractGraph)</code></pre><p>Returns a list of the vertices of graph g sorted in non-increasing order of their degrees</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.sparse_jacobian!" href="#SparseDiffTools.sparse_jacobian!"><code>SparseDiffTools.sparse_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse_jacobian!(J::AbstractMatrix, ad, cache::AbstractMaybeSparseJacobianCache, f, x)
sparse_jacobian!(J::AbstractMatrix, ad, cache::AbstractMaybeSparseJacobianCache, f!, fx,
    x)</code></pre><p>Inplace update the matrix <code>J</code> with the Jacobian of <code>f</code> at <code>x</code> using the AD backend <code>ad</code>.</p><p><code>cache</code> is the cache object returned by <code>sparse_jacobian_cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L153-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.sparse_jacobian!-Tuple{AbstractMatrix, ADTypes.AbstractADType, SparseDiffTools.AbstractMaybeSparsityDetection, Vararg{Any}}" href="#SparseDiffTools.sparse_jacobian!-Tuple{AbstractMatrix, ADTypes.AbstractADType, SparseDiffTools.AbstractMaybeSparsityDetection, Vararg{Any}}"><code>SparseDiffTools.sparse_jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_jacobian!(J::AbstractMatrix, ad::AbstractADType, sd::AbstractSparsityDetection,
    f, x; fx=nothing)
sparse_jacobian!(J::AbstractMatrix, ad::AbstractADType, sd::AbstractSparsityDetection,
    f!, fx, x)</code></pre><p>Sequentially calls <code>sparse_jacobian_cache</code> and <code>sparse_jacobian!</code> to compute the Jacobian of <code>f</code> at <code>x</code>. Use this if the jacobian for <code>f</code> is computed exactly once. In all other cases, use <code>sparse_jacobian_cache</code> once to generate the cache and use <code>sparse_jacobian!</code> with the same cache to compute the jacobian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.sparse_jacobian-Tuple{ADTypes.AbstractADType, SparseDiffTools.AbstractMaybeSparseJacobianCache, Vararg{Any}}" href="#SparseDiffTools.sparse_jacobian-Tuple{ADTypes.AbstractADType, SparseDiffTools.AbstractMaybeSparseJacobianCache, Vararg{Any}}"><code>SparseDiffTools.sparse_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_jacobian(ad::AbstractADType, cache::AbstractMaybeSparseJacobianCache, f, x)
sparse_jacobian(ad::AbstractADType, cache::AbstractMaybeSparseJacobianCache, f!, fx, x)</code></pre><p>Use the sparsity detection <code>cache</code> for computing the sparse Jacobian. This allocates a new Jacobian at every function call.</p><p>If <code>x</code> is a StaticArray, then this function tries to use a non-allocating implementation for the jacobian computation. This is possible only for a limited backends currently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L212-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.sparse_jacobian-Tuple{ADTypes.AbstractADType, SparseDiffTools.AbstractMaybeSparsityDetection, Vararg{Any}}" href="#SparseDiffTools.sparse_jacobian-Tuple{ADTypes.AbstractADType, SparseDiffTools.AbstractMaybeSparsityDetection, Vararg{Any}}"><code>SparseDiffTools.sparse_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse_jacobian(ad::AbstractADType, sd::AbstractMaybeSparsityDetection, f, x; fx=nothing)
sparse_jacobian(ad::AbstractADType, sd::AbstractMaybeSparsityDetection, f!, fx, x)</code></pre><p>Sequentially calls <code>sparse_jacobian_cache</code> and <code>sparse_jacobian!</code> to compute the Jacobian of <code>f</code> at <code>x</code>. Use this if the jacobian for <code>f</code> is computed exactly once. In all other cases, use <code>sparse_jacobian_cache</code> once to generate the cache and use <code>sparse_jacobian!</code> with the same cache to compute the jacobian.</p><p>If <code>x</code> is a StaticArray, then this function tries to use a non-allocating implementation for the jacobian computation. This is possible only for a limited backends currently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L187-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.sparse_jacobian_cache" href="#SparseDiffTools.sparse_jacobian_cache"><code>SparseDiffTools.sparse_jacobian_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse_jacobian_cache(ad::AbstractADType, sd::AbstractSparsityDetection, f, x;
    fx=nothing)
sparse_jacobian_cache(ad::AbstractADType, sd::AbstractSparsityDetection, f!, fx, x)</code></pre><p>Takes the underlying AD backend <code>ad</code>, sparsity detection algorithm <code>sd</code>, function <code>f</code>, and input <code>x</code> and returns a cache object that can be used to compute the Jacobian.</p><p>If <code>fx</code> is not specified, it will be computed by calling <code>f(x)</code>.</p><p><strong>Returns</strong></p><p>A cache for computing the Jacobian of type <code>AbstractMaybeSparseJacobianCache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/highlevel/common.jl#L164-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.uncolor_all!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, Integer}" href="#SparseDiffTools.uncolor_all!-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}, Integer}"><code>SparseDiffTools.uncolor_all!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uncolor_all(F::AbstractVector{&lt;:Integer}, A::AbstractVector{&lt;:Integer}, start::Integer)</code></pre><p>Uncolors all vertices A[i] where i is greater than or equal to start</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.uncolored_vertex_of_maximal_degree-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}}" href="#SparseDiffTools.uncolored_vertex_of_maximal_degree-Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:Integer}}"><code>SparseDiffTools.uncolored_vertex_of_maximal_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uncolored_vertex_of_maximal_degree(A::AbstractVector{&lt;:Integer},F::AbstractVector{&lt;:Integer})</code></pre><p>Returns an uncolored vertex from the partially colored graph which has the highest degree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/backtracking_coloring.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseDiffTools.vertex_degree-Tuple{VertexSafeGraphs.VSafeGraph, Int64}" href="#SparseDiffTools.vertex_degree-Tuple{VertexSafeGraphs.VSafeGraph, Int64}"><code>SparseDiffTools.vertex_degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertex_degree(g, z)</code></pre><p>Find the degree of the vertex z which belongs to the graph g.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/SparseDiffTools.jl/blob/d5e3e498dd46f11d68ebb42b2aef3f03e24c5b1b/src/coloring/contraction_coloring.jl#L116-L120">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 18 April 2024 17:08">Thursday 18 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
